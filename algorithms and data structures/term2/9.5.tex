\documentclass[12pt, a4paper]{article}

\usepackage[left=1.5cm, right=1.5cm, top=2cm, bottom=2cm, bindingoffset=0cm, headheight=15pt]{geometry}
\usepackage{fancyhdr}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{libertine}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}

\setmainfont{Linux Libertine}

\pagestyle{fancy}
\chead{Алгоритмы и структуры данных, задача 9.5}
\cfoot{Михайлов Максим, M3137}

\begin{document}
    
\section*{Условие}

Есть дерево, каждое ребро может быть либо включено, либо выключено. Научитесь обрабатывать такие запросы за полилог:
\begin{itemize}
    \item Изменить состояние всех ребер на пути от $u$ до $v$
    \item Найти число компонент связности по включенным ребрам
\end{itemize}

\section*{Решение}

Заметим, что в дереве число компнент связности $=$ число выключенных ребер + 1. Тогда задача сводится к нахождению числа выключенных ребер.

Разобьем дерево по HLD и в каждом Heavy-сегменте будем поддерживать дерево отрезков, которое считает число выключенных ребер, т.е. выставленных битов в битовом отрезке. Мы умеем делать инвертирование битов на подотрезке, это уже было на практике. Light-ребра тоже помнят свою включенность.

Запрос на изменение состояния выглядит так:
\begin{enumerate}
    \item Найдем LCA $u, v$
    \item На пути $u\to$ LCA и $v\to$ LCA найдем все Heavy-сегменты, через которые мы проходим. В этих сегментах найдем подотрезок, по которому мы проходим \textit{(это делается за $O(1)$, если в каждом элементе Heavy хранить указатель на верхний элемент в Heavy)}
    \item На каждом таком подотрезке инвертируем значения и из каждого Heavy передадим в родителя обновленное число выключенных ребер. Если Heavy-сегмент передал в Light-ребро значение, то это ребро передает вверх полученное +1, если Light выключено и просто полученное иначе.
    \item Эти передачи доходят до корня, это значение и есть число компонент связности.
\end{enumerate}

\end{document}